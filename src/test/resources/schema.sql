CREATE schema dict;
SET search_path TO dict;

create table consent
(
    consent_id        integer generated by default as identity
        primary key,
    dataset_id        integer      not null,
    consent_code      varchar(512) not null,
    description       varchar(512) not null,
    authz             varchar(512) not null,
    participant_count integer      not null,
    variable_count    integer      not null,
    sample_count      integer      not null,
    unique (consent_code, dataset_id)
);

create table dataset
(
    dataset_id   integer generated by default as identity
        primary key,
    ref          varchar(512) not null
        unique,
    full_name    varchar(512) not null,
    abbreviation varchar(512) not null,
    description  text default ''::text
);

create table concept_node
(
    concept_node_id   integer generated by default as identity
        primary key,
    dataset_id        integer                                              not null
        constraint fk_study
            references dataset on delete cascade,
    name              varchar                                         not null,
    display           varchar                                        not null,
    concept_type      varchar(32)    default 'categorical'::character varying not null,
    concept_path      varchar(10000) default 'INVALID'::character varying  not null,
    parent_id         integer
        constraint fk_parent
            references concept_node on delete cascade,
    searchable_fields tsvector
);

create unique index concept_node_concept_path_idx
    on concept_node (md5(concept_path::text));

create table concept_node_meta
(
    concept_node_meta_id integer generated by default as identity
        primary key,
    concept_node_id      integer      not null
        constraint fk_concept_node
            references concept_node on delete cascade,
    key                  varchar(256) not null,
    value                text         not null,
    unique (key, concept_node_id)
);


create table dataset_harmonization
(
    dataset_harmonization_id integer generated by default as identity
        primary key,
    harmonized_dataset_id    integer not null
        constraint fk_harmonized_dataset_id
            references dataset on delete cascade,
    source_dataset_id        integer not null
        constraint fk_source_dataset_id
            references dataset on delete cascade,
    constraint harmonization_da_key
        unique (harmonized_dataset_id, source_dataset_id)
);

create table dataset_meta
(
    dataset_meta_id integer generated by default as identity
        primary key,
    dataset_id      integer      not null
        constraint fk_study
            references dataset on delete cascade,
    key             varchar(256) not null,
    value           text         not null,
    unique (key, dataset_id)
);

create table facet_category
(
    facet_category_id integer generated by default as identity
        primary key,
    name              varchar(512) not null,
    display           varchar(512) not null,
    description       text default ''::text,
    unique (name)
);

create table facet
(
    facet_id          integer generated by default as identity
        primary key,
    facet_category_id integer      not null
        constraint fk_category
            references facet_category on delete cascade,
    name              varchar(512) not null,
    display           varchar(512) not null,
    description       text default ''::text,
    parent_id         integer
        constraint fk_parent
            references facet on delete cascade,
    unique (name, facet_category_id)
);

create table facet__concept_node
(
    facet__concept_node_id integer generated by default as identity
        primary key,
    facet_id               integer not null
        constraint fk_facet
            references facet on delete cascade,
    concept_node_id        integer not null
        constraint fk_concept_node
            references concept_node on delete cascade,
    unique (facet_id, concept_node_id)
);

create table facet_category_meta
(
    facet_category_meta_id integer generated by default as identity,
    facet_category_id      integer      not null
        constraint fk_facet_category
            references facet_category on delete cascade,
    key                    varchar(256) not null,
    value                  text         not null,
    unique (key, facet_category_id)
);

create table facet_meta
(
    facet_meta_id integer generated by default as identity,
    facet_id      integer      not null
        constraint fk_facet
            references facet on delete cascade,
    key           varchar(256) not null,
    value         text         not null,
    unique (key, facet_id)
);

ALTER TABLE dict.concept_node ADD COLUMN concept_path_md5 text GENERATED ALWAYS AS (md5(concept_path::text)) STORED;
CREATE UNIQUE INDEX idx_concept_node_md5 ON dict.concept_node(concept_path_md5);

CREATE TABLE IF NOT EXISTS dict.update_info (
    LAST_UPDATED TIMESTAMP NOT NULL DEFAULT '2000-01-01 00:00:00',
    DATABASE_VERSION INT NOT NULL DEFAULT 3
);

--We should consider changing this to a trigger i.e.
/*
CREATE  FUNCTION update_timestamp()
RETURNS TRIGGER AS $$
BEGIN
    UPDATE dict.update_info set last_updated = NOW();
    RETURN NULL;
END;
$$ language 'plpgsql';
DO
   BEGIN
       FOR table_name in
           SELECT tablename from pg_tables
           where schemaname = 'dict' and tablename !- 'update_info'
       LOOP
           EXECUTE 'CREATE OR REPLACE TRIGGER dictionary_update AFTER INSERT OR UPDATE OR DELETE OR TRUNCATE ON
            dict.dataset
            FOR EACH STATEMENT
            EXECUTE PROCEDURE update_timestamp();
        END LOOP;
END
*/

INSERT INTO dict.update_info (LAST_UPDATED, DATABASE_VERSION) VALUES ('2000-01-01 00:00:00', 3);


CREATE TABLE dict.remote_dictionary (
    REMOTE_DICTIONARY_ID SERIAL PRIMARY KEY,
    NAME CHARACTER VARYING(512) NOT NULL,
    UUID UUID NOT NULL,
    LAST_UPDATED TIMESTAMP
);

CREATE TABLE dict.concept_node__remote_dictionary (
    CONCEPT_NODE_ID integer NOT NULL,
    REMOTE_DICTIONARY_ID integer NOT NULL,
    CONSTRAINT fk_remote_dictionary FOREIGN KEY (REMOTE_DICTIONARY_ID) REFERENCES dict.remote_dictionary(REMOTE_DICTIONARY_ID),
    CONSTRAINT fk_concept_node FOREIGN KEY (CONCEPT_NODE_ID) REFERENCES dict.concept_node(CONCEPT_NODE_ID)
);
